### 1、微任务和宏任务

微任务和宏任务都是异步任务。实际开发中碰到比较常见的微任务和宏任务分别是：

微任务：Promise的then和catch的回调函数

宏任务：定时器setTimeout setInterval



```
setTimeout(()=>{
	console.log('1')
},0)

new Promise(resolve => {
	resolve()
}).then(()=>{
	console.log('2')
})

console.log('3')

// 输出：
// '3'
// '2'
// '1'
```

__微任务优先级高于宏任务，就是说执行栈清空后，会先去微任务队列看有没有要执行的微任务，如果没有，才去宏任务队列中__



### 2、定时器的任务编排

1、当代码执行时碰到定时器，会把定时器放到定时器模块中进行计时，当计时结束之，会把定时器的回调函数放到宏任务队列中等待被执行

2、需要注意的是：不是说计时一结束马上就会执行定时器的回调函数，还要等待主线程执行完。所以定时器的时间不一定是准确的，有可能会晚点



### 3、Promise微任务处理逻辑

 __promise构造函数中的代码是同步的，then或者catch中的回调函数才是异步代码__

```
setTimeout(()=>{// 1.（第一次轮询）碰到宏任务，开始计时，计时结束把回调函数放到宏任务队列
	console.log('定时器'); // 6.（第一次轮询）当前主线程为空，微任务队列为空，就到宏任务队列中找宏任务，输出'定时器'
	setTimeout(()=>{ // 7.（第一次轮询）碰到宏任务，开始计时，计时结束把回调函数放到宏任务队列
		console.log('timeout timeout') // 11.（第二次轮询）此时主线程为空，微任务队列为空，在宏任务队列找到宏任务，拿到主线程执行，输出'timeout timeout'，至此，第二次轮询结束
	},0)
	new Promise(resolve => {
		console.log('setTimeout Promise'); // 8.（第一次轮询）碰到同步代码，输出'setTimeout Promise'
		resolve();
	}).then(()=>{// 9.（第一次轮询）碰到微任务，把微任务放到微任务队列，至此，第一次轮询结束
		console.log('setTimeout then');// 10.（第二次轮询）此时主线程为空，在微任务队列找到微任务并拿到主线程执行，输出'setTimeout then'
	})
},0);
new Promise(resolve => {
	console.log('Promise');  // 2.（第一次轮询）同步代码，输出'Promise'
	resolve()
}).then(()=>{ // 3.（第一次轮询）碰到微任务，把微任务放到微任务队列
	console.log('then') // 5.（第一次轮询）主线程清空，到微任务队列找到微任务，拿到主线程执行，微任务执行结束后主线程清空
})
console.log('后盾人'); // 4.（第一次轮询）同步代码，输出'then'

// 输出：
// promise
// 后盾人
// then
// 定时器
// settime promise
// settime then
// timeout timeout
```

这里其实就是遵循有同步代码执行同步代码，当主线程清空，会去微任务队列中找待执行的任务，把待执行任务拿到主线程执行，执行完之后主线程清空，再到微任务队列找，如果没有待执行的微任务，就到宏任务队列找，并把待执行的宏任务放到主线程执行。一直以这个圈在轮询



### 4、dom渲染任务

js执行与dom渲染互斥



### 5、任务共享内存

```
let i = 0;
setTimeout(()=>{
	console.log(++i)
},0)
setTimeout(()=>{
	console.log(++i)
})
// 1
// 2
```

__即使定时器设置的时间是一样的，但是他们的回调函数被放进任务队列的时间也是有先后差别的，所以不会同时执行两个任务__



### 6、进度条实例体验任务轮询



### 7、任务拆分成多个子任务





